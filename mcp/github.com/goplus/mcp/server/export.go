// export by github.com/goplus/igop/cmd/qexp

package server

import (
	q "github.com/goplus/mcp/server"

	"go/constant"
	"reflect"

	"github.com/goplus/igop"
)

func init() {
	igop.RegisterPackage(&igop.Package{
		Name: "server",
		Path: "github.com/goplus/mcp/server",
		Deps: map[string]string{
			"context":                            "context",
			"encoding/json":                      "json",
			"errors":                             "errors",
			"github.com/goplus/mcp/server/stdio": "stdio",
			"github.com/goplus/mcp/server/svx":   "svx",
			"github.com/mark3labs/mcp-go/mcp":    "mcp",
			"github.com/mark3labs/mcp-go/server": "server",
			"github.com/yosida95/uritemplate/v3": "uritemplate",
			"log":                                "log",
			"reflect":                            "reflect",
			"strconv":                            "strconv",
			"strings":                            "strings",
		},
		Interfaces: map[string]reflect.Type{
			"PromptProto":   reflect.TypeOf((*q.PromptProto)(nil)).Elem(),
			"ResourceProto": reflect.TypeOf((*q.ResourceProto)(nil)).Elem(),
			"ToolProto":     reflect.TypeOf((*q.ToolProto)(nil)).Elem(),
		},
		NamedTypes: map[string]reflect.Type{
			"JsonContent":              reflect.TypeOf((*q.JsonContent)(nil)).Elem(),
			"JsonResourceContents":     reflect.TypeOf((*q.JsonResourceContents)(nil)).Elem(),
			"MCPApp":                   reflect.TypeOf((*q.MCPApp)(nil)).Elem(),
			"PromptApp":                reflect.TypeOf((*q.PromptApp)(nil)).Elem(),
			"PromptAppProto":           reflect.TypeOf((*q.PromptAppProto)(nil)).Elem(),
			"ResourceApp":              reflect.TypeOf((*q.ResourceApp)(nil)).Elem(),
			"ResourceAppProto":         reflect.TypeOf((*q.ResourceAppProto)(nil)).Elem(),
			"TextResourceByteContents": reflect.TypeOf((*q.TextResourceByteContents)(nil)).Elem(),
			"ToolApp":                  reflect.TypeOf((*q.ToolApp)(nil)).Elem(),
			"ToolAppProto":             reflect.TypeOf((*q.ToolAppProto)(nil)).Elem(),
		},
		AliasTypes: map[string]reflect.Type{
			"Role": reflect.TypeOf((*q.Role)(nil)).Elem(),
		},
		Vars: map[string]reflect.Value{},
		Funcs: map[string]reflect.Value{
			"Content__0":       reflect.ValueOf(q.Content__0),
			"Content__1":       reflect.ValueOf(q.Content__1),
			"Content__2":       reflect.ValueOf(q.Content__2),
			"Content__3":       reflect.ValueOf(q.Content__3),
			"Embedded__0":      reflect.ValueOf(q.Embedded__0),
			"Embedded__1":      reflect.ValueOf(q.Embedded__1),
			"Embedded__2":      reflect.ValueOf(q.Embedded__2),
			"Embedded__3":      reflect.ValueOf(q.Embedded__3),
			"Gopt_MCPApp_Main": reflect.ValueOf(q.Gopt_MCPApp_Main),
			"Image__0":         reflect.ValueOf(q.Image__0),
			"Image__1":         reflect.ValueOf(q.Image__1),
			"Multiple":         reflect.ValueOf(q.Multiple),
			"NewError__0":      reflect.ValueOf(q.NewError__0),
			"NewError__1":      reflect.ValueOf(q.NewError__1),
			"Number__0":        reflect.ValueOf(q.Number__0),
			"Number__1":        reflect.ValueOf(q.Number__1),
			"Number__2":        reflect.ValueOf(q.Number__2),
			"Text__0":          reflect.ValueOf(q.Text__0),
			"Text__1":          reflect.ValueOf(q.Text__1),
		},
		TypedConsts: map[string]igop.TypedConst{
			"RoleAssistant": {reflect.TypeOf(q.RoleAssistant), constant.MakeString(string(q.RoleAssistant))},
			"RoleUser":      {reflect.TypeOf(q.RoleUser), constant.MakeString(string(q.RoleUser))},
		},
		UntypedConsts: map[string]igop.UntypedConst{
			"GopPackage": {"untyped bool", constant.MakeBool(bool(q.GopPackage))},
		},
		Source: source,
	})
}

var source = "package server\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"github.com/goplus/mcp/server/svx\"\n\t\"github.com/mark3labs/mcp-go/mcp\"\n\t\"github.com/mark3labs/mcp-go/server\"\n\t_ \"github.com/goplus/mcp/server/stdio\"\n\t\"errors\"\n\t\"strings\"\n\t\"github.com/yosida95/uritemplate/v3\"\n)\n\nconst (\n\tGopPackage = true\n)\n\ntype multiContents struct {\n\tdata\t[]mcp.Content\n\tisErr\tbool\n\tmcp.Content\n}\n\ntype JsonContent struct {\n\tJSON any\n}\n\nfunc Text__0(text string) mcp.Content {\n\treturn mcp.NewTextContent(text)\n}\n\nfunc Text__1(v JsonContent) mcp.Content {\n\tb, err := json.Marshal(v.JSON)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn mcp.NewTextContent(string(b))\n}\n\nfunc Number__0(val float64) mcp.Content {\n\treturn mcp.NewTextContent(strconv.FormatFloat(val, 'f', -1, 64))\n}\n\nfunc Number__1(val float64, prec int) mcp.Content {\n\treturn mcp.NewTextContent(strconv.FormatFloat(val, 'f', prec, 64))\n}\n\nfunc Number__2(val float64, fmt byte, prec int) mcp.Content {\n\treturn mcp.NewTextContent(strconv.FormatFloat(val, fmt, prec, 64))\n}\n\nfunc Image__0(mimeType, imageData string) mcp.Content {\n\treturn &mcp.ImageContent{\n\t\tType:\t\t\"image\",\n\t\tData:\t\timageData,\n\t\tMIMEType:\tmimeType,\n\t}\n}\n\nfunc Image__1(text, mimeType, imageData string) mcp.Content {\n\treturn Multiple(\n\t\tText__0(text),\n\t\tImage__0(mimeType, imageData),\n\t)\n}\n\nfunc Embedded__0(text *mcp.TextResourceContents) mcp.Content {\n\treturn mcp.NewEmbeddedResource(text)\n}\n\nfunc Embedded__1(blob *mcp.BlobResourceContents) mcp.Content {\n\treturn mcp.NewEmbeddedResource(blob)\n}\n\nfunc Embedded__2(v *JsonResourceContents) mcp.Content {\n\treturn mcp.NewEmbeddedResource(Content__2(v))\n}\n\nfunc Embedded__3(text *TextResourceByteContents) mcp.Content {\n\treturn mcp.NewEmbeddedResource(Content__3(text))\n}\n\nfunc Multiple(contents ...mcp.Content) mcp.Content {\n\treturn &multiContents{\n\t\tdata: contents,\n\t}\n}\n\nfunc NewError__0(text string) mcp.Content {\n\treturn &multiContents{\n\t\tdata: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType:\t\"text\",\n\t\t\t\tText:\ttext,\n\t\t\t},\n\t\t},\n\t\tisErr:\ttrue,\n\t}\n}\n\nfunc NewError__1(text string, err error) mcp.Content {\n\tif err != nil {\n\t\ttext = text + \": \" + err.Error()\n\t}\n\treturn NewError__0(text)\n}\n\ntype JsonResourceContents struct {\n\tURI\tstring\n\n\tJSON\tany\n}\n\ntype TextResourceByteContents struct {\n\tURI\tstring\n\n\tMIMEType\tstring\n\n\tText\t[]byte\n}\n\nfunc Content__0(text *mcp.TextResourceContents) *mcp.TextResourceContents {\n\treturn text\n}\n\nfunc Content__1(blob *mcp.BlobResourceContents) *mcp.BlobResourceContents {\n\treturn blob\n}\n\nfunc Content__2(v *JsonResourceContents) *mcp.TextResourceContents {\n\tb, err := json.Marshal(v.JSON)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn &mcp.TextResourceContents{\n\t\tURI:\t\tv.URI,\n\t\tMIMEType:\t\"application/json\",\n\t\tText:\t\tstring(b),\n\t}\n}\n\nfunc Content__3(text *TextResourceByteContents) *mcp.TextResourceContents {\n\treturn &mcp.TextResourceContents{\n\t\tURI:\t\ttext.URI,\n\t\tMIMEType:\ttext.MIMEType,\n\t\tText:\t\tstring(text.Text),\n\t}\n}\n\ntype withContext struct {\n\tctx\tcontext.Context\n\tsvr\t*server.MCPServer\n}\n\nfunc (p *withContext) Notify(method string, params map[string]any) {\n\tp.svr.SendNotificationToClient(p.ctx, method, params)\n}\n\ntype MCPApp struct {\n\tsvr\t*server.MCPServer\n\tlas\tfunc(addr string, svr *server.MCPServer) error\n\taddr\tstring\n}\n\nfunc (p *MCPApp) Sys() *server.MCPServer {\n\treturn p.svr\n}\n\nfunc (p *MCPApp) Server(name, version string) {\n\tp.svr = server.NewMCPServer(name, version)\n\tp.addr = \"stdio:\"\n\tif p.las == nil {\n\t\tp.las = svx.ListenAndServe\n\t}\n}\n\nfunc (p *MCPApp) Run(addr string) {\n\tp.addr = addr\n}\n\nfunc (p *MCPApp) SetLAS(las func(addr string, svr *server.MCPServer) error) {\n\tp.las = las\n}\n\nfunc (p *MCPApp) serve() error {\n\treturn p.las(p.addr, p.svr)\n}\n\ntype stop struct{}\n\ntype iAppProto interface {\n\tserve() error\n\tSys() *server.MCPServer\n\tMainEntry()\n}\n\ntype ResourceProto interface {\n\taddTo(self ResourceProto, svr *server.MCPServer)\n\tMain(ctx context.Context, request mcp.ReadResourceRequest, t *ResourceAppProto) []mcp.ResourceContents\n\tClassclone() ResourceProto\n}\n\ntype ToolProto interface {\n\taddTo(self ToolProto, svr *server.MCPServer)\n\tMain(ctx context.Context, request mcp.CallToolRequest, t *ToolAppProto) mcp.Content\n\tClassclone() ToolProto\n}\n\ntype PromptProto interface {\n\taddTo(self PromptProto, svr *server.MCPServer)\n\tMain(ctx context.Context, request mcp.GetPromptRequest, t *PromptAppProto) (string, []mcp.PromptMessage)\n\tClassclone() PromptProto\n}\n\nfunc Gopt_MCPApp_Main(app iAppProto, resources []ResourceProto, tools []ToolProto, prompts []PromptProto) {\n\tapp.MainEntry()\n\tsvr := app.Sys()\n\tfor _, r := range resources {\n\t\tinitProj(r, app)\n\t\tr.addTo(r, svr)\n\t}\n\tfor _, h := range tools {\n\t\tinitProj(h, app)\n\t\th.addTo(h, svr)\n\t}\n\tfor _, p := range prompts {\n\t\tinitProj(p, app)\n\t\tp.addTo(p, svr)\n\t}\n\terr := app.serve()\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n}\n\nfunc initProj(work, app any) {\n\treflect.ValueOf(work).Elem().Field(1).Set(reflect.ValueOf(app))\n}\n\ntype Role = mcp.Role\n\nconst (\n\tRoleUser\t= mcp.RoleUser\n\tRoleAssistant\t= mcp.RoleAssistant\n)\n\ntype PromptAppProto struct {\n\tprompt\tmcp.Prompt\n\topts\t[]mcp.ArgumentOption\n\tparent\t*server.MCPServer\n}\n\ntype PromptApp struct {\n\t*PromptAppProto\n\twithContext\n\trequest\tmcp.GetPromptRequest\n\tisClone\tbool\n}\n\nfunc (p *PromptApp) Gop_Env(name string) string {\n\treturn p.request.Params.Arguments[name]\n}\n\nfunc (p *PromptApp) Main(ctx context.Context, request mcp.GetPromptRequest, t *PromptAppProto) (string, []mcp.PromptMessage) {\n\tif t == nil {\n\t\tp.ctx = ctx\n\t\tp.request = request\n\t\tp.isClone = true\n\t} else {\n\t\tp.PromptAppProto = t\n\t\tp.svr = t.parent\n\t}\n\treturn \"\", nil\n}\n\nfunc initPromptApp(self PromptProto, svr *server.MCPServer) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\tif _, ok := e.(stop); !ok {\n\t\t\t\tpanic(e)\n\t\t\t}\n\t\t}\n\t}()\n\tself.Main(context.TODO(), mcp.GetPromptRequest{}, &PromptAppProto{\n\t\tprompt:\tmcp.NewPrompt(\"\"),\n\t\tparent:\tsvr,\n\t})\n}\n\nfunc (p *PromptApp) Prompt__0(name string, fn func()) {\n\tif !p.isClone {\n\t\tp.prompt.Name = name\n\t\tfn()\n\t\tpanic(stop{})\n\t}\n}\n\nfunc (p *PromptApp) Prompt__1(role Role, content mcp.Content) mcp.PromptMessage {\n\treturn mcp.NewPromptMessage(role, content)\n}\n\nfunc (p *PromptApp) Description(description string) {\n\tif p.opts != nil {\n\t\tp.opts = append(p.opts, mcp.ArgumentDescription(description))\n\t} else {\n\t\tmcp.WithPromptDescription(description)(&p.prompt)\n\t}\n}\n\nfunc (p *PromptApp) Arg(name string, fn ...func()) {\n\tif len(fn) > 0 {\n\t\tp.opts = make([]mcp.ArgumentOption, 0, 2)\n\t\tfn[0]()\n\t}\n\tmcp.WithArgument(name, p.opts...)(&p.prompt)\n\tp.opts = nil\n}\n\nfunc (p *PromptApp) Required() {\n\tp.opts = append(p.opts, mcp.RequiredArgument())\n}\n\nfunc (p *PromptApp) addTo(self PromptProto, svr *server.MCPServer) {\n\tclone := self.Classclone\n\tinitPromptApp(self, svr)\n\tsvr.AddPrompt(p.prompt, func(ctx context.Context, request mcp.GetPromptRequest) (ret *mcp.GetPromptResult, err error) {\n\t\tdefer func() {\n\t\t\tif e := recover(); e != nil {\n\t\t\t\tswitch e := e.(type) {\n\t\t\t\tcase string:\n\t\t\t\t\terr = errors.New(e)\n\t\t\t\tcase error:\n\t\t\t\t\terr = e\n\t\t\t\tdefault:\n\t\t\t\t\terr = errors.New(\"unknown error\")\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tdescription, messages := clone().Main(ctx, request, nil)\n\t\tret = mcp.NewGetPromptResult(description, messages)\n\t\treturn\n\t})\n}\n\ntype ResourceAppProto struct {\n\tresource\tmcp.Resource\n\ttemplate\tmcp.ResourceTemplate\n\tparent\t\t*server.MCPServer\n}\n\ntype ResourceApp struct {\n\t*ResourceAppProto\n\twithContext\n\trequest\t\tmcp.ReadResourceRequest\n\tvalues\t\turitemplate.Values\n\tisClone\t\tbool\n\thasTempl\tbool\n}\n\nfunc (p *ResourceApp) RequestURI() string {\n\treturn p.request.Params.URI\n}\n\nfunc (p *ResourceApp) Gop_Env(name string) any {\n\tif p.hasTempl {\n\t\tif p.values == nil {\n\t\t\tp.values = p.template.URITemplate.Match(p.request.Params.URI)\n\t\t}\n\t\tif v, ok := p.values[name]; ok {\n\t\t\tif v.T == uritemplate.ValueTypeString {\n\t\t\t\treturn v.V[0]\n\t\t\t} else {\n\t\t\t\treturn v.V\n\t\t\t}\n\t\t}\n\t}\n\tif v, ok := p.request.Params.Arguments[name]; ok {\n\t\treturn v\n\t}\n\treturn nil\n}\n\nfunc (p *ResourceApp) Main(ctx context.Context, request mcp.ReadResourceRequest, t *ResourceAppProto) []mcp.ResourceContents {\n\tif t == nil {\n\t\tp.ctx = ctx\n\t\tp.request = request\n\t\tp.isClone = true\n\t} else {\n\t\tp.ResourceAppProto = t\n\t\tp.svr = t.parent\n\t}\n\treturn nil\n}\n\nfunc initResourceApp(self ResourceProto, svr *server.MCPServer) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\tif _, ok := e.(stop); !ok {\n\t\t\t\tpanic(e)\n\t\t\t}\n\t\t}\n\t}()\n\tself.Main(context.TODO(), mcp.ReadResourceRequest{}, &ResourceAppProto{\n\t\tparent: svr,\n\t})\n}\n\nfunc hasTemplate(uri string) bool {\n\treturn strings.IndexByte(uri, '{') >= 0\n}\n\nfunc (p *ResourceApp) Resource(uri string, name string, fn func()) {\n\tif !p.isClone {\n\t\tp.hasTempl = hasTemplate(uri)\n\t\tif p.hasTempl {\n\t\t\tp.template = mcp.NewResourceTemplate(uri, name)\n\t\t} else {\n\t\t\tp.resource = mcp.NewResource(uri, name)\n\t\t}\n\t\tfn()\n\t\tpanic(stop{})\n\t}\n}\n\nfunc (p *ResourceApp) Description(description string) {\n\tif p.hasTempl {\n\t\tmcp.WithTemplateDescription(description)(&p.template)\n\t} else {\n\t\tmcp.WithResourceDescription(description)(&p.resource)\n\t}\n}\n\nfunc (p *ResourceApp) MimeType(mime string) {\n\tif p.hasTempl {\n\t\tmcp.WithTemplateMIMEType(mime)(&p.template)\n\t} else {\n\t\tmcp.WithMIMEType(mime)(&p.resource)\n\t}\n}\n\nfunc (p *ResourceApp) addTo(self ResourceProto, svr *server.MCPServer) {\n\tclone := self.Classclone\n\thandle := func(ctx context.Context, request mcp.ReadResourceRequest) (ret []mcp.ResourceContents, err error) {\n\t\tdefer func() {\n\t\t\tif e := recover(); e != nil {\n\t\t\t\tswitch e := e.(type) {\n\t\t\t\tcase string:\n\t\t\t\t\terr = errors.New(e)\n\t\t\t\tcase error:\n\t\t\t\t\terr = e\n\t\t\t\tdefault:\n\t\t\t\t\terr = errors.New(\"unknown error\")\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tret = clone().Main(ctx, request, nil)\n\t\treturn\n\t}\n\tinitResourceApp(self, svr)\n\tif p.hasTempl {\n\t\tsvr.AddResourceTemplate(p.template, handle)\n\t} else {\n\t\tsvr.AddResource(p.resource, handle)\n\t}\n}\n\ntype ToolAppProto struct {\n\tparent\t*server.MCPServer\n\ttool\tmcp.Tool\n\topts\t[]mcp.PropertyOption\n\tkind\tbyte\n}\n\ntype ToolApp struct {\n\t*ToolAppProto\n\twithContext\n\trequest\tmcp.CallToolRequest\n\targs\tmap[string]any\n\tisClone\tbool\n}\n\nconst (\n\tkindString\t= 1\n\tkindNumber\t= 2\n\tkindBoolean\t= 3\n\tkindArray\t= 4\n\tkindObject\t= 5\n)\n\nfunc (p *ToolApp) MetaProgressToken() mcp.ProgressToken {\n\tif meta := p.request.Params.Meta; meta != nil {\n\t\treturn meta.ProgressToken\n\t}\n\treturn nil\n}\n\nfunc (p *ToolApp) Gop_Env(name string) any {\n\treturn p.args[name]\n}\n\nfunc (p *ToolApp) Main(ctx context.Context, request mcp.CallToolRequest, t *ToolAppProto) mcp.Content {\n\tif t == nil {\n\t\tp.ctx = ctx\n\t\tp.request = request\n\t\tp.args = request.GetArguments()\n\t\tp.isClone = true\n\t} else {\n\t\tp.ToolAppProto = t\n\t\tp.svr = t.parent\n\t}\n\treturn nil\n}\n\nfunc initToolApp(self ToolProto, svr *server.MCPServer) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\tif _, ok := e.(stop); !ok {\n\t\t\t\tpanic(e)\n\t\t\t}\n\t\t}\n\t}()\n\tself.Main(context.TODO(), mcp.CallToolRequest{}, &ToolAppProto{\n\t\ttool:\tmcp.NewTool(\"\"),\n\t\tparent:\tsvr,\n\t})\n}\n\nfunc (p *ToolApp) Tool(name string, fn func()) {\n\tif !p.isClone {\n\t\tp.tool.Name = name\n\t\tfn()\n\t\tpanic(stop{})\n\t}\n}\n\nfunc (p *ToolApp) Description(description string) {\n\tif p.opts != nil {\n\t\tp.opts = append(p.opts, mcp.Description(description))\n\t} else {\n\t\tmcp.WithDescription(description)(&p.tool)\n\t}\n}\n\nfunc (p *ToolApp) Annotation(annotation mcp.ToolAnnotation) {\n\tmcp.WithToolAnnotation(annotation)(&p.tool)\n}\n\nfunc (p *ToolApp) String(name string, fn ...func()) {\n\top, np := p.ToolAppProto, &ToolAppProto{\n\t\tkind: kindString,\n\t}\n\tp.ToolAppProto = np\n\tif len(fn) > 0 {\n\t\tnp.opts = make([]mcp.PropertyOption, 0, 2)\n\t\tfn[0]()\n\t}\n\tmcp.WithString(name, np.opts...)(&op.tool)\n\tp.ToolAppProto = op\n}\n\nfunc (p *ToolApp) Float(name string, fn ...func()) {\n\top, np := p.ToolAppProto, &ToolAppProto{\n\t\tkind: kindNumber,\n\t}\n\tp.ToolAppProto = np\n\tif len(fn) > 0 {\n\t\tnp.opts = make([]mcp.PropertyOption, 0, 2)\n\t\tfn[0]()\n\t}\n\tmcp.WithNumber(name, np.opts...)(&op.tool)\n\tp.ToolAppProto = op\n}\n\nfunc (p *ToolApp) Bool(name string, fn ...func()) {\n\top, np := p.ToolAppProto, &ToolAppProto{\n\t\tkind: kindBoolean,\n\t}\n\tp.ToolAppProto = np\n\tif len(fn) > 0 {\n\t\tnp.opts = make([]mcp.PropertyOption, 0, 2)\n\t\tfn[0]()\n\t}\n\tmcp.WithBoolean(name, np.opts...)(&op.tool)\n\tp.ToolAppProto = op\n}\n\nfunc (p *ToolApp) Array(name string, fn ...func()) {\n\top, np := p.ToolAppProto, &ToolAppProto{\n\t\ttool:\tmcp.NewTool(\"\"),\n\t\tkind:\tkindArray,\n\t}\n\tp.ToolAppProto = np\n\tif len(fn) > 0 {\n\t\tnp.opts = make([]mcp.PropertyOption, 0, 2)\n\t\tfn[0]()\n\t}\n\tif items, ok := np.tool.InputSchema.Properties[\"items\"]; ok {\n\t\tnp.opts = append(np.opts, mcp.Items(items))\n\t}\n\tmcp.WithArray(name, np.opts...)(&op.tool)\n\tp.ToolAppProto = op\n}\n\nfunc (p *ToolApp) Set(name string, fn ...func()) {\n\tp.Array(name, func() {\n\t\tp.opts = append(p.opts, mcp.UniqueItems(true))\n\t\tif len(fn) > 0 {\n\t\t\tfn[0]()\n\t\t}\n\t})\n}\n\nfunc (p *ToolApp) Object(name string, fn ...func()) {\n\top, np := p.ToolAppProto, &ToolAppProto{\n\t\ttool:\tmcp.NewTool(\"\"),\n\t\tkind:\tkindObject,\n\t}\n\tp.ToolAppProto = np\n\tif len(fn) > 0 {\n\t\tnp.opts = make([]mcp.PropertyOption, 0, 2)\n\t\tfn[0]()\n\t}\n\tnp.opts = append(np.opts, mcp.Properties(np.tool.InputSchema.Properties))\n\tmcp.WithObject(name, np.opts...)(&op.tool)\n\tp.ToolAppProto = op\n}\n\nfunc (p *ToolApp) Required() {\n\tp.opts = append(p.opts, mcp.Required())\n}\n\nfunc (p *ToolApp) Defval__0(value string) {\n\tif p.kind != kindString {\n\t\tpanic(\"defval: not a string property\")\n\t}\n\tp.opts = append(p.opts, mcp.DefaultString(value))\n}\n\nfunc (p *ToolApp) Defval__1(value float64) {\n\tif p.kind != kindNumber {\n\t\tpanic(\"defval: not a number property\")\n\t}\n\tp.opts = append(p.opts, mcp.DefaultNumber(value))\n}\n\nfunc (p *ToolApp) Defval__2(value bool) {\n\tif p.kind != kindBoolean {\n\t\tpanic(\"defval: not a boolean property\")\n\t}\n\tp.opts = append(p.opts, mcp.DefaultBool(value))\n}\n\nfunc (p *ToolApp) Maxval(value float64) {\n\tif p.kind != kindNumber {\n\t\tpanic(\"maxval: not a number property\")\n\t}\n\tp.opts = append(p.opts, mcp.Max(value))\n}\n\nfunc (p *ToolApp) Minval(value float64) {\n\tif p.kind != kindNumber {\n\t\tpanic(\"minval: not a number property\")\n\t}\n\tp.opts = append(p.opts, mcp.Min(value))\n}\n\nfunc (p *ToolApp) Maxlen(n int) {\n\tswitch p.kind {\n\tcase kindString:\n\t\tp.opts = append(p.opts, mcp.MaxLength(n))\n\tcase kindArray:\n\t\tp.opts = append(p.opts, mcp.MaxItems(n))\n\tcase kindObject:\n\t\tp.opts = append(p.opts, mcp.MaxProperties(n))\n\tdefault:\n\t\tpanic(\"maxlen: not a string, array or object property\")\n\t}\n}\n\nfunc (p *ToolApp) Minlen(n int) {\n\tswitch p.kind {\n\tcase kindString:\n\t\tp.opts = append(p.opts, mcp.MinLength(n))\n\tcase kindArray:\n\t\tp.opts = append(p.opts, mcp.MinItems(n))\n\tcase kindObject:\n\t\tp.opts = append(p.opts, mcp.MinProperties(n))\n\tdefault:\n\t\tpanic(\"minlen: not a string, array or object property\")\n\t}\n}\n\nfunc (p *ToolApp) MultipleOf(value float64) {\n\tif p.kind != kindNumber {\n\t\tpanic(\"multipleOf: not a number property\")\n\t}\n\tp.opts = append(p.opts, mcp.MultipleOf(value))\n}\n\nfunc (p *ToolApp) Enum(values ...string) {\n\tif p.kind != kindString {\n\t\tpanic(\"enum: not a string property\")\n\t}\n\tp.opts = append(p.opts, mcp.Enum(values...))\n}\n\nfunc (p *ToolApp) Pattern(pattern string) {\n\tif p.kind != kindString {\n\t\tpanic(\"pattern: not a string property\")\n\t}\n\tp.opts = append(p.opts, mcp.Pattern(pattern))\n}\n\nfunc (p *ToolApp) Title(title string) {\n\tp.opts = append(p.opts, mcp.Title(title))\n}\n\nfunc (p *ToolApp) addTo(self ToolProto, svr *server.MCPServer) {\n\tclone := self.Classclone\n\tinitToolApp(self, svr)\n\tsvr.AddTool(p.tool, func(ctx context.Context, request mcp.CallToolRequest) (ret *mcp.CallToolResult, err error) {\n\t\tdefer func() {\n\t\t\tif e := recover(); e != nil {\n\t\t\t\tswitch e := e.(type) {\n\t\t\t\tcase string:\n\t\t\t\t\terr = errors.New(e)\n\t\t\t\tcase error:\n\t\t\t\t\terr = e\n\t\t\t\tdefault:\n\t\t\t\t\terr = errors.New(\"unknown error\")\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tcontent := clone().Main(ctx, request, nil)\n\t\tret = new(mcp.CallToolResult)\n\t\tif multi, ok := content.(*multiContents); ok {\n\t\t\tret.Content, ret.IsError = multi.data, multi.isErr\n\t\t} else {\n\t\t\tret.Content = []mcp.Content{content}\n\t\t}\n\t\treturn\n\t})\n}\n"
