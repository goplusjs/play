// export by github.com/goplus/igop/cmd/qexp

package test

import (
	q "github.com/qiniu/x/test"

	"go/constant"
	"reflect"

	"github.com/goplus/igop"
)

func init() {
	igop.RegisterPackage(&igop.Package{
		Name: "test",
		Path: "github.com/qiniu/x/test",
		Deps: map[string]string{
			"encoding/json": "json",
			"fmt":           "fmt",
			"log":           "log",
			"os":            "os",
			"reflect":       "reflect",
			"strconv":       "strconv",
			"strings":       "strings",
			"testing":       "testing",
			"time":          "time",
		},
		Interfaces: map[string]reflect.Type{
			"CaseT": reflect.TypeOf((*q.CaseT)(nil)).Elem(),
		},
		NamedTypes: map[string]reflect.Type{
			"Case":     reflect.TypeOf((*q.Case)(nil)).Elem(),
			"TestingT": reflect.TypeOf((*q.TestingT)(nil)).Elem(),
			"TyAnySet": reflect.TypeOf((*q.TyAnySet)(nil)).Elem(),
		},
		AliasTypes: map[string]reflect.Type{},
		Vars:       map[string]reflect.Value{},
		Funcs: map[string]reflect.Value{
			"Diff":                  reflect.ValueOf(q.Diff),
			"Fatal":                 reflect.ValueOf(q.Fatal),
			"Fatalf":                reflect.ValueOf(q.Fatalf),
			"Gopt_Case_MatchAny":    reflect.ValueOf(q.Gopt_Case_MatchAny),
			"Gopt_Case_MatchAnySet": reflect.ValueOf(q.Gopt_Case_MatchAnySet),
			"Gopt_Case_MatchMap":    reflect.ValueOf(q.Gopt_Case_MatchMap),
			"NewT":                  reflect.ValueOf(q.NewT),
			"Set__2":                reflect.ValueOf(q.Set__2),
		},
		TypedConsts: map[string]igop.TypedConst{},
		UntypedConsts: map[string]igop.UntypedConst{
			"GopPackage":           {"untyped bool", constant.MakeBool(bool(q.GopPackage))},
			"Gopo_Gopt_Case_Match": {"untyped string", constant.MakeString(string(q.Gopo_Gopt_Case_Match))},
		},
		Source: source,
	})
}

var source = "package test\n\nimport (\n\t\"testing\"\n\t\"time\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"log\"\n\t\"os\"\n)\n\ntype CaseT interface {\n\tName() string\n\n\tFail()\n\n\tFailed() bool\n\n\tFailNow()\n\n\tLog(args ...any)\n\n\tLogf(format string, args ...any)\n\n\tErrorln(args ...any)\n\n\tErrorf(format string, args ...any)\n\n\tFatal(args ...any)\n\n\tFatalf(format string, args ...any)\n\n\tSkip(args ...any)\n\n\tSkipf(format string, args ...any)\n\n\tSkipNow()\n\n\tSkipped() bool\n\n\tHelper()\n\n\tCleanup(f func())\n\n\tTempDir() string\n\n\tRun(name string, f func()) bool\n\n\tDeadline() (deadline time.Time, ok bool)\n}\n\ntype TestingT struct {\n\t*testing.T\n}\n\nfunc NewT(t *testing.T) TestingT {\n\treturn TestingT{t}\n}\n\nfunc (p TestingT) Errorln(args ...any) {\n\tt := p.T\n\tt.Helper()\n\tt.Error(args...)\n}\n\nfunc (p TestingT) Run(name string, doSth func()) bool {\n\treturn p.T.Run(name, func(t *testing.T) {\n\t\tdoSth()\n\t})\n}\n\nconst (\n\tGopPackage = true\n)\n\ntype basetype interface {\n\tstring | int | bool | float64\n}\n\nfunc toMapAny[T basetype](val map[string]T) map[string]any {\n\tret := make(map[string]any, len(val))\n\tfor k, v := range val {\n\t\tret[k] = v\n\t}\n\treturn ret\n}\n\nfunc toSlice(val []map[string]any) []any {\n\tret := make([]any, len(val))\n\tfor i, v := range val {\n\t\tret[i] = v\n\t}\n\treturn ret\n}\n\nfunc toSliceAny[T basetype](val []map[string]T) []any {\n\tret := make([]any, len(val))\n\tfor i, v := range val {\n\t\tret[i] = toMapAny(v)\n\t}\n\treturn ret\n}\n\nfunc tryToMapAny(val any) (ret map[string]any, ok bool) {\n\tv := reflect.ValueOf(val)\n\treturn castMapAny(v)\n}\n\nfunc castMapAny(v reflect.Value) (ret map[string]any, ok bool) {\n\tif v.Kind() != reflect.Map || v.Type().Key() != tyString {\n\t\treturn\n\t}\n\tret, ok = make(map[string]any, v.Len()), true\n\tfor it := v.MapRange(); it.Next(); {\n\t\tkey := it.Key().String()\n\t\tret[key] = it.Value().Interface()\n\t}\n\treturn\n}\n\nvar (\n\ttyString = reflect.TypeOf(\"\")\n)\n\ntype baseelem interface {\n\tstring\n}\n\ntype baseslice interface {\n\t[]string\n}\n\ntype TySet[T baseelem] []T\ntype TyAnySet []any\n\nfunc Set__0[T baseelem](vals ...T) TySet[T] {\n\treturn TySet[T](vals)\n}\n\nfunc Set__1[T []string](v *Var__3[T]) TySet[string] {\n\treturn TySet[string](v.Val())\n}\n\nfunc Set__2(vals ...any) TyAnySet {\n\treturn TyAnySet(vals)\n}\n\ntype Case struct {\n\tCaseT\n}\n\nfunc nameCtx(name []string) string {\n\tif name != nil {\n\t\treturn \" (\" + strings.Join(name, \".\") + \")\"\n\t}\n\treturn \"\"\n}\n\nconst (\n\tGopo_Gopt_Case_Match = \"Gopt_Case_MatchTBase,Gopt_Case_MatchMap,Gopt_Case_MatchSlice,Gopt_Case_MatchBaseSlice,Gopt_Case_MatchSet,Gopt_Case_MatchAnySet,Gopt_Case_MatchAny\"\n)\n\nfunc Gopt_Case_MatchTBase[T basetype](t CaseT, expected, got T, name ...string) {\n\tif expected != got {\n\t\tt.Helper()\n\t\tt.Fatalf(\"unmatched value%s - expected: %v, got: %v\\n\", nameCtx(name), expected, got)\n\t}\n}\n\nfunc Gopt_Case_MatchMap(t CaseT, expected, got map[string]any, name ...string) {\n\tt.Helper()\n\tidx := len(name)\n\tname = append(name, \"\")\n\tfor key, ev := range expected {\n\t\tname[idx] = key\n\t\tGopt_Case_MatchAny(t, ev, got[key], name...)\n\t}\n}\n\nfunc Gopt_Case_MatchSlice[T any](t CaseT, expected []T, got []any, name ...string) {\n\tt.Helper()\n\tif len(expected) != len(got) {\n\t\tt.Fatalf(\"unmatched slice%s length - expected: %d, got: %d\\n\", nameCtx(name), len(expected), len(got))\n\t}\n\tidx := len(name) - 1\n\tif idx < 0 {\n\t\tidx, name = 0, []string{\"$\"}\n\t}\n\tfor i, ev := range expected {\n\t\tname[idx] = \"[\" + strconv.Itoa(i) + \"]\"\n\t\tGopt_Case_MatchAny(t, ev, got[i], name...)\n\t}\n}\n\nfunc Gopt_Case_MatchBaseSlice[T baseelem](t CaseT, expected, got []T, name ...string) {\n\tt.Helper()\n\tif len(expected) != len(got) {\n\t\tt.Fatalf(\"unmatched slice%s length - expected: %d, got: %d\\n\", nameCtx(name), len(expected), len(got))\n\t}\n\tidx := len(name) - 1\n\tif idx < 0 {\n\t\tidx, name = 0, []string{\"$\"}\n\t}\n\tfor i, ev := range expected {\n\t\tname[idx] = \"[\" + strconv.Itoa(i) + \"]\"\n\t\tGopt_Case_MatchTBase(t, ev, got[i], name...)\n\t}\n}\n\nfunc Gopt_Case_MatchSet[T baseelem](t CaseT, expected TySet[T], got []T, name ...string) {\n\tif len(expected) != len(got) {\n\t\tt.Fatalf(\"unmatched set%s length - expected: %d, got: %d\\n\", nameCtx(name), len(expected), len(got))\n\t}\n\tfor _, gv := range got {\n\t\tif !hasElem(gv, expected) {\n\t\t\tt.Fatalf(\"unmatched set%s: expected: %v, value %v doesn't exist in it\\n\", nameCtx(name), expected, gv)\n\t\t}\n\t}\n}\n\nfunc Gopt_Case_MatchAnySet(t CaseT, expected TyAnySet, got any, name ...string) {\n\tif gv, ok := got.([]any); ok {\n\t\tmatchAnySet(t, expected, gv)\n\t\treturn\n\t}\n\tvgot := reflect.ValueOf(got)\n\tif vgot.Kind() != reflect.Slice {\n\t\tt.Fatalf(\"unmatched set%s: expected: %v, got a non slice value: %v\\n\", nameCtx(name), expected, got)\n\t}\n\tfor i, n := 0, vgot.Len(); i < n; i++ {\n\t\tgv := vgot.Index(i).Interface()\n\t\tif !hasAnyElem(gv, expected) {\n\t\t\tt.Fatalf(\"unmatched set%s: expected: %v, value %v doesn't exist in it\\n\", nameCtx(name), expected, gv)\n\t\t}\n\t}\n}\n\nfunc matchAnySet(t CaseT, expected TyAnySet, got []any, name ...string) {\n\tif len(expected) != len(got) {\n\t\tt.Fatalf(\"unmatched set%s length - expected: %d, got: %d\\n\", nameCtx(name), len(expected), len(got))\n\t}\n\tfor _, gv := range got {\n\t\tif !hasAnyElem(gv, expected) {\n\t\t\tt.Fatalf(\"unmatched set%s: expected: %v, value %v doesn't exist in it\\n\", nameCtx(name), expected, gv)\n\t\t}\n\t}\n}\n\nfunc hasElem[T baseelem](v T, expected []T) bool {\n\tfor _, ev := range expected {\n\t\tif reflect.DeepEqual(v, ev) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc hasAnyElem(v any, expected []any) bool {\n\tfor _, ev := range expected {\n\t\tif v == ev {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc Gopt_Case_MatchAny(t CaseT, expected, got any, name ...string) {\n\tt.Helper()\nretry:\n\tswitch ev := expected.(type) {\n\tcase string:\n\t\tswitch gv := got.(type) {\n\t\tcase string:\n\t\t\tGopt_Case_MatchTBase(t, ev, gv, name...)\n\t\t\treturn\n\t\tcase *Var__0[string]:\n\t\t\tGopt_Case_MatchTBase(t, ev, gv.Val(), name...)\n\t\t\treturn\n\t\t}\n\tcase int:\n\t\tswitch gv := got.(type) {\n\t\tcase int:\n\t\t\tGopt_Case_MatchTBase(t, ev, gv, name...)\n\t\t\treturn\n\t\tcase *Var__0[int]:\n\t\t\tGopt_Case_MatchTBase(t, ev, gv.Val(), name...)\n\t\t\treturn\n\t\t}\n\tcase bool:\n\t\tswitch gv := got.(type) {\n\t\tcase bool:\n\t\t\tGopt_Case_MatchTBase(t, ev, gv, name...)\n\t\t\treturn\n\t\tcase *Var__0[bool]:\n\t\t\tGopt_Case_MatchTBase(t, ev, gv.Val(), name...)\n\t\t\treturn\n\t\t}\n\tcase float64:\n\t\tswitch gv := got.(type) {\n\t\tcase float64:\n\t\t\tGopt_Case_MatchTBase(t, ev, gv, name...)\n\t\t\treturn\n\t\tcase *Var__0[float64]:\n\t\t\tGopt_Case_MatchTBase(t, ev, gv.Val(), name...)\n\t\t\treturn\n\t\t}\n\tcase map[string]any:\n\t\tswitch gv := got.(type) {\n\t\tcase map[string]any:\n\t\t\tGopt_Case_MatchMap(t, ev, gv, name...)\n\t\t\treturn\n\t\tcase *Var__1[map[string]any]:\n\t\t\tGopt_Case_MatchMap(t, ev, gv.Val(), name...)\n\t\t\treturn\n\t\tdefault:\n\t\t\tif gv, ok := tryToMapAny(got); ok {\n\t\t\t\tGopt_Case_MatchMap(t, ev, gv, name...)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\tcase []any:\n\t\tswitch gv := got.(type) {\n\t\tcase []any:\n\t\t\tGopt_Case_MatchSlice(t, ev, gv, name...)\n\t\t\treturn\n\t\tcase *Var__2[[]any]:\n\t\t\tGopt_Case_MatchSlice(t, ev, gv.Val(), name...)\n\t\t\treturn\n\t\t}\n\tcase []string:\n\t\tswitch gv := got.(type) {\n\t\tcase []string:\n\t\t\tGopt_Case_MatchBaseSlice(t, ev, gv, name...)\n\t\t\treturn\n\t\tcase *Var__3[[]string]:\n\t\t\tGopt_Case_MatchBaseSlice(t, ev, gv.Val(), name...)\n\t\t\treturn\n\t\tcase []any:\n\t\t\tGopt_Case_MatchSlice(t, ev, gv, name...)\n\t\t\treturn\n\t\t}\n\tcase TySet[string]:\n\t\tswitch gv := got.(type) {\n\t\tcase []string:\n\t\t\tGopt_Case_MatchSet(t, ev, gv, name...)\n\t\t\treturn\n\t\tcase *Var__3[[]string]:\n\t\t\tGopt_Case_MatchSet(t, ev, gv.Val(), name...)\n\t\t\treturn\n\t\t}\n\tcase TyAnySet:\n\t\tswitch gv := got.(type) {\n\t\tcase *Var__2[[]any]:\n\t\t\tGopt_Case_MatchAnySet(t, ev, gv.Val(), name...)\n\t\t\treturn\n\t\tdefault:\n\t\t\tGopt_Case_MatchAnySet(t, ev, gv, name...)\n\t\t\treturn\n\t\t}\n\tcase *Var__0[string]:\n\t\tswitch gv := got.(type) {\n\t\tcase string:\n\t\t\tev.Match(t, gv, name...)\n\t\t\treturn\n\t\tcase *Var__0[string]:\n\t\t\tev.Match(t, gv.Val(), name...)\n\t\t\treturn\n\t\tcase nil:\n\t\t\tev.MatchNil(t, name...)\n\t\t\treturn\n\t\t}\n\tcase *Var__0[int]:\n\t\tswitch gv := got.(type) {\n\t\tcase int:\n\t\t\tev.Match(t, gv, name...)\n\t\t\treturn\n\t\tcase *Var__0[int]:\n\t\t\tev.Match(t, gv.Val(), name...)\n\t\t\treturn\n\t\tcase nil:\n\t\t\tev.MatchNil(t, name...)\n\t\t\treturn\n\t\t}\n\tcase *Var__0[bool]:\n\t\tswitch gv := got.(type) {\n\t\tcase bool:\n\t\t\tev.Match(t, gv, name...)\n\t\t\treturn\n\t\tcase *Var__0[bool]:\n\t\t\tev.Match(t, gv.Val(), name...)\n\t\t\treturn\n\t\tcase nil:\n\t\t\tev.MatchNil(t, name...)\n\t\t\treturn\n\t\t}\n\tcase *Var__0[float64]:\n\t\tswitch gv := got.(type) {\n\t\tcase float64:\n\t\t\tev.Match(t, gv, name...)\n\t\t\treturn\n\t\tcase *Var__0[float64]:\n\t\t\tev.Match(t, gv.Val(), name...)\n\t\t\treturn\n\t\tcase nil:\n\t\t\tev.MatchNil(t, name...)\n\t\t\treturn\n\t\t}\n\tcase *Var__1[map[string]any]:\n\t\tswitch gv := got.(type) {\n\t\tcase map[string]any:\n\t\t\tev.Match(t, gv, name...)\n\t\t\treturn\n\t\tcase *Var__1[map[string]any]:\n\t\t\tev.Match(t, gv.Val(), name...)\n\t\t\treturn\n\t\t}\n\tcase *Var__2[[]any]:\n\t\tswitch gv := got.(type) {\n\t\tcase []any:\n\t\t\tev.Match(t, gv, name...)\n\t\t\treturn\n\t\tcase *Var__2[[]any]:\n\t\t\tev.Match(t, gv.Val(), name...)\n\t\t\treturn\n\t\t}\n\tcase *Var__3[[]string]:\n\t\tswitch gv := got.(type) {\n\t\tcase []string:\n\t\t\tev.Match(t, gv, name...)\n\t\t\treturn\n\t\tcase *Var__3[[]string]:\n\t\t\tev.Match(t, gv.Val(), name...)\n\t\t\treturn\n\t\t}\n\n\tcase map[string]string:\n\t\texpected = toMapAny(ev)\n\t\tgoto retry\n\tcase map[string]int:\n\t\texpected = toMapAny(ev)\n\t\tgoto retry\n\tcase map[string]bool:\n\t\texpected = toMapAny(ev)\n\t\tgoto retry\n\tcase map[string]float64:\n\t\texpected = toMapAny(ev)\n\t\tgoto retry\n\n\tcase []map[string]any:\n\t\texpected = toSlice(ev)\n\t\tgoto retry\n\tcase []map[string]string:\n\t\texpected = toSliceAny(ev)\n\t\tgoto retry\n\n\tdefault:\n\t\tif v, ok := tryToMapAny(expected); ok {\n\t\t\texpected = v\n\t\t\tgoto retry\n\t\t}\n\t\tif reflect.DeepEqual(expected, got) {\n\t\t\treturn\n\t\t}\n\t}\n\tt.Fatalf(\n\t\t\"unmatched%s - expected: %v (%T), got: %v (%T)\\n\",\n\t\tnameCtx(name), expected, expected, got, got,\n\t)\n}\n\ntype Var__0[T basetype] struct {\n\tval\tT\n\tvalid\tbool\n}\n\nfunc (p *Var__0[T]) check() {\n\tif !p.valid {\n\t\tFatal(\"read variable value before initialization\")\n\t}\n}\n\nfunc (p *Var__0[T]) Ok() bool {\n\treturn p.valid\n}\n\nfunc (p *Var__0[T]) String() string {\n\tp.check()\n\treturn fmt.Sprint(p.val)\n}\n\nfunc (p *Var__0[T]) Val() T {\n\tp.check()\n\treturn p.val\n}\n\nfunc (p *Var__0[T]) MarshalJSON() ([]byte, error) {\n\tp.check()\n\treturn json.Marshal(p.val)\n}\n\nfunc (p *Var__0[T]) UnmarshalJSON(data []byte) error {\n\tp.valid = true\n\treturn json.Unmarshal(data, &p.val)\n}\n\nfunc (p *Var__0[T]) Equal(t CaseT, v T) bool {\n\tp.check()\n\treturn p.val == v\n}\n\nfunc (p *Var__0[T]) Match(t CaseT, v T, name ...string) {\n\tif !p.valid {\n\t\tp.val, p.valid = v, true\n\t\treturn\n\t}\n\tt.Helper()\n\tGopt_Case_MatchTBase(t, p.val, v, name...)\n}\n\nfunc (p *Var__0[T]) MatchNil(t CaseT, name ...string) {\n\tif p.valid {\n\t\tt.Helper()\n\t\tt.Fatalf(\"unmatched%s - expected: nil, got: %v\\n\", nameCtx(name), p.val)\n\t}\n}\n\ntype Var__1[T map[string]any] struct {\n\tval T\n}\n\nfunc (p *Var__1[T]) check() {\n\tif p.val == nil {\n\t\tFatal(\"read variable value before initialization\")\n\t}\n}\n\nfunc (p *Var__1[T]) Ok() bool {\n\treturn p.val != nil\n}\n\nfunc (p *Var__1[T]) Val() T {\n\tp.check()\n\treturn p.val\n}\n\nfunc (p *Var__1[T]) MarshalJSON() ([]byte, error) {\n\tp.check()\n\treturn json.Marshal(p.val)\n}\n\nfunc (p *Var__1[T]) UnmarshalJSON(data []byte) error {\n\treturn json.Unmarshal(data, &p.val)\n}\n\nfunc (p *Var__1[T]) Match(t CaseT, v T, name ...string) {\n\tif p.val == nil {\n\t\tp.val = v\n\t\treturn\n\t}\n\tt.Helper()\n\tGopt_Case_MatchMap(t, p.val, v, name...)\n}\n\ntype Var__2[T []any] struct {\n\tval\tT\n\tvalid\tbool\n}\n\nfunc (p *Var__2[T]) check() {\n\tif !p.valid {\n\t\tFatal(\"read variable value before initialization\")\n\t}\n}\n\nfunc (p *Var__2[T]) Ok() bool {\n\treturn p.valid\n}\n\nfunc (p *Var__2[T]) Val() T {\n\tp.check()\n\treturn p.val\n}\n\nfunc (p *Var__2[T]) MarshalJSON() ([]byte, error) {\n\tp.check()\n\treturn json.Marshal(p.val)\n}\n\nfunc (p *Var__2[T]) UnmarshalJSON(data []byte) error {\n\tp.valid = true\n\treturn json.Unmarshal(data, &p.val)\n}\n\nfunc (p *Var__2[T]) Match(t CaseT, v T, name ...string) {\n\tif p.val == nil {\n\t\tp.val, p.valid = v, true\n\t\treturn\n\t}\n\tt.Helper()\n\tGopt_Case_MatchSlice(t, p.val, v, name...)\n}\n\ntype Var__3[T baseslice] struct {\n\tval\tT\n\tvalid\tbool\n}\n\nfunc (p *Var__3[T]) check() {\n\tif !p.valid {\n\t\tFatal(\"read variable value before initialization\")\n\t}\n}\n\nfunc (p *Var__3[T]) Ok() bool {\n\treturn p.valid\n}\n\nfunc (p *Var__3[T]) Val() T {\n\tp.check()\n\treturn p.val\n}\n\nfunc (p *Var__3[T]) MarshalJSON() ([]byte, error) {\n\tp.check()\n\treturn json.Marshal(p.val)\n}\n\nfunc (p *Var__3[T]) UnmarshalJSON(data []byte) error {\n\tp.valid = true\n\treturn json.Unmarshal(data, &p.val)\n}\n\nfunc (p *Var__3[T]) Match(t CaseT, v T, name ...string) {\n\tif p.val == nil {\n\t\tp.val, p.valid = v, true\n\t\treturn\n\t}\n\tt.Helper()\n\tGopt_Case_MatchBaseSlice(t, p.val, v, name...)\n}\n\nfunc Gopx_Var_Cast__0[T basetype]() *Var__0[T] {\n\treturn new(Var__0[T])\n}\n\nfunc Gopx_Var_Cast__1[T map[string]any]() *Var__1[T] {\n\treturn new(Var__1[T])\n}\n\nfunc Gopx_Var_Cast__2[T []any]() *Var__2[T] {\n\treturn new(Var__2[T])\n}\n\nfunc Gopx_Var_Cast__3[T []string]() *Var__3[T] {\n\treturn new(Var__3[T])\n}\nfunc Fatal(v ...any) {\n\tlog.Panicln(v...)\n}\n\nfunc Fatalf(format string, v ...any) {\n\tlog.Panicf(format, v...)\n}\n\nfunc Diff(t *testing.T, outfile string, dst, src []byte) bool {\n\tline := 1\n\toffs := 0\n\tfor i := 0; i < len(dst) && i < len(src); i++ {\n\t\td := dst[i]\n\t\ts := src[i]\n\t\tif d != s {\n\t\t\tos.WriteFile(outfile, dst, 0644)\n\t\t\tt.Errorf(\"dst:%d: %s\\n\", line, dst[offs:])\n\t\t\tt.Errorf(\"src:%d: %s\\n\", line, src[offs:])\n\t\t\treturn true\n\t\t}\n\t\tif s == '\\n' {\n\t\t\tline++\n\t\t\toffs = i + 1\n\t\t}\n\t}\n\tif len(dst) != len(src) {\n\t\tos.WriteFile(outfile, dst, 0644)\n\t\tt.Errorf(\"len(dst) = %d, len(src) = %d\\ndst = %q\\nsrc = %q\", len(dst), len(src), dst, src)\n\t\treturn true\n\t}\n\treturn false\n}\n"
